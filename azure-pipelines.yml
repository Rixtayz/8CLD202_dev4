# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

# trigger:
# - master

pool: "default"

variables:
- name: RG
  value: 'Guro'
- name: RG_Location
  value: 'eastus'
- name: Vault
  value: 'GuroKeyVault'
- name: AppConfig
  value: 'GuroAppConfiguration'
- name: LogAnalytics
  value: 'LogAnalyticsName'
- name: InfrastructureFolder
  value: 'CloudInfrastructure'
- name: ApplicationInsight
  value: 'ApplicationInsight'
- name: BlobName
  value: 'guroblobstore'
- name: BlobContainer1
  value: 'unvalidated'
- name: BlobContainer2
  value: 'validated'
- name: SBusName
  value: 'GuroSb'
- name: EventHubName
  value: 'GuroEventHub'
- name: CosmosDBName
  value: 'gurocosmo'
- name: ContentName
  value: 'GuroContentSafety'
- name: ContainerRegistryName
  value: 'GuroRegistry'
- name: DockerRegistryServiceConnectionName
  value: 'Docker Registry Dynamic'
- name: AzureSubscription
  value: 'Azure subscription 1(970fcef5-9c23-4f7d-a11b-5a96d104f066)'
- name: AzureDevOpsPAT #https://learn.microsoft.com/en-us/azure/devops/cli/log-in-via-pat?view=azure-devops&tabs=windows
  value: 'r9UMg3Jrr1NwuFXXZx7k8VMirDz2ezTKJVoocbBUS7yiurpvPen2JQQJ99BDACAAAAAAAAAAAAASAZDOrV1D'

- name: ServiceConnectionExists
  value: false
- name: ServiceConnectionId
  value: ''
  
steps:
  - task: AzureResourceManagerTemplateDeployment@3
    displayName: ARM Deployment
    inputs:
      deploymentScope: 'Resource Group'
      azureResourceManagerConnection: $(AzureSubscription)
      action: 'Create Or Update Resource Group'
      resourceGroupName: '$(RG)'
      location: '$(RG_Location)'
      templateLocation: 'Linked artifact'
      csmFile: '$(Build.SourcesDirectory)\$(InfrastructureFolder)\azuredeploy.json'
      csmParametersFile: '$(Build.SourcesDirectory)\$(InfrastructureFolder)\azuredeploy.parameters.json'
      overrideParameters: '-ContentSafetyname $(ContentName) -NoSQLname $(CosmosDBName) -ServiceBusName $(SBusName) -location $(RG_Location) -VaultName $(Vault) -AppConfigName $(AppConfig) -LogAnalyticsName $(LogAnalytics) -ApplicationInsightName $(ApplicationInsight) -storageAccountName $(BlobName) -storageBlobContainerName1 $(BlobContainer1) -storageBlobContainerName2 $(BlobContainer2) -EventHubName $(EventHubName) -ContainerRegistryName $(ContainerRegistryName)'
      deploymentMode: 'Incremental'
      deploymentOutputs: 'Deployment1'
  - task: AzureCLI@2
    displayName: 'Check Existing Service Connection'
    inputs:
      azureSubscription: $(AzureSubscription)
      scriptType: 'ps'
      scriptLocation: 'inlineScript'
      inlineScript: |
        az extension add --name azure-devops
        az config set extension.dynamic_install_allow_preview=true
        $serviceConnectionName = "$(DockerRegistryServiceConnectionName)"
        $existingServiceConnection = az devops service-endpoint list `
          --project "$(System.TeamProject)" `
          --organization "$(System.CollectionUri)" `
          --query "[?name=='$serviceConnectionName']" `
          --output json

        if ($existingServiceConnection -eq "[]") {
          Write-Host "Service connection does not exist."
          Write-Host "##vso[task.setvariable variable=ServiceConnectionExists]false"
        } else {
          $serviceConnectionId = ($existingServiceConnection | ConvertFrom-Json)[0].id
          Write-Host "Service connection already exists with ID: $serviceConnectionId"
          Write-Host "##vso[task.setvariable variable=ServiceConnectionExists]true"
          Write-Host "##vso[task.setvariable variable=ServiceConnectionId]$serviceConnectionId"
          Write-Host $serviceConnectionId
        }
    env:
      AZURE_DEVOPS_EXT_PAT: $(AzureDevOpsPAT)

  - task: PowerShell@2
    displayName: 'Generate Service Connection JSON'
    condition: eq(variables['ServiceConnectionExists'], 'false')
    inputs:
      targetType: 'inline'
      script: |
        $dockerRegistryUrl = "https://{0}" -f $(Deployment1.dockerRegistryUrl.value)
        $dockerUsername = $(Deployment1.dockerUsername.value)
        $dockerPassword = $(Deployment1.dockerPassword.value)
        $serviceConnectionName = '$(DockerRegistryServiceConnectionName)'
        $jsonFilePath = '$(System.DefaultWorkingDirectory)\service-endpoint-config.json'

        $serviceEndpointJson = @{
            data = @{
                registrytype = 'Others'
                registry = $dockerRegistryUrl
            }
            authorization = @{
                parameters = @{
                    username = $dockerUsername
                    password = $dockerPassword
                }
                scheme = 'UsernamePassword'
            }
            name = $serviceConnectionName
            type = 'dockerregistry'
        }

        $serviceEndpointJsonString = $serviceEndpointJson | ConvertTo-Json -Depth 10 -Compress
        [System.IO.File]::WriteAllBytes($jsonFilePath, [System.Text.Encoding]::UTF8.GetBytes($serviceEndpointJsonString))
        Write-Host "JSON file generated at: $jsonFilePath"

  - task: AzureCLI@2
    displayName: 'Create Docker Registry Service Connection (Dynamic)'
    condition: eq(variables['ServiceConnectionExists'], 'false')
    inputs:
      azureSubscription: $(AzureSubscription)
      scriptType: 'ps'
      scriptLocation: 'inlineScript'
      inlineScript: |
        az extension add --name azure-devops
        az config set extension.dynamic_install_allow_preview=true

        # Create the service connection and capture the output
        $serviceConnectionOutput = az devops service-endpoint create `
          --service-endpoint-configuration "$(System.DefaultWorkingDirectory)\service-endpoint-config.json" `
          --project "$(System.TeamProject)" `
          --organization "$(System.CollectionUri)" `
          --output json

        # Extract the 'id' field from the output
        $serviceConnectionId = ($serviceConnectionOutput | ConvertFrom-Json).id
        Write-Host "Service connection created with ID: $serviceConnectionId"

        # Set the ID as a pipeline variable
        Write-Host "##vso[task.setvariable variable=ServiceConnectionId]$serviceConnectionId"

    env:
      AZURE_DEVOPS_EXT_PAT: $(AzureDevOpsPAT)

  - task: AzureCLI@2
    displayName: 'Grant Permissions for Service Connection'
    condition: eq(variables['ServiceConnectionExists'], 'false')
    inputs:
      azureSubscription: $(AzureSubscription)
      scriptType: 'ps'
      scriptLocation: 'inlineScript'
      inlineScript: |
        # Grant access to Project Collection Build Service account
        az devops service-endpoint update `
          --id $(ServiceConnectionId) `
          --project "$(System.TeamProject)" `
          --organization "$(System.CollectionUri)" `
          --enable-for-all
          
    env:
      AZURE_DEVOPS_EXT_PAT: $(AzureDevOpsPAT)